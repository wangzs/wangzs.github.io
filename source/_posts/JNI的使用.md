title: JNI使用方法
date: 2016-03-09  08:38
tag: [Android, JNI]
---

# [Java Native Interface][0]
### 一、JNI简介
#### 1.1 JNI with C
* 在Java类中使用C代码
```java
 public class HelloJNI {
	 static {
		 // 在运行时载入native库：Windows下为hello.dll 或者 Unixes下的libhello.so
		 System.loadLibrary("hello");
	 }
	 private native void helloWorld();
	 // test
	 public static void main(String[] args) {
		 new HelloJNI().helloWorld();    // 实际调用native的方法
	 }
 }

 // 编译改java文件为对应的"HelloJNI.class"
 > javac HelloJNI.java
```
<!--more-->

* 在C/C++层创建native的实际实现
```java
	// 先通过javah生产对应的C/C++头文件（注意调用javah时其所在的当前目录）
	> javah HelloJNI

	/* DO NOT EDIT THIS FILE - it is machine generated */
	#include <jni.h>
	/* Header for class HelloJNI */
	#ifndef _Included_HelloJNI
	#define _Included_HelloJNI
	#ifdef __cplusplus
	extern "C" {
	#endif
	/*
	 * Class:     HelloJNI
	 * Method:    helloWorld
	 * Signature: ()V
	 */
	JNIEXPORT void JNICALL Java_HelloJNI_helloWorld
	  (JNIEnv *, jobject);

	#ifdef __cplusplus
	}
	#endif
	#endif
```
生产的C/C++头文件中的函数命名规则：`Java_{package_and_classname}_{function_name}(JNI arguments)`
###### 参数
> * JNIEnv*: JNI环境的reference，通过它可以访问所有的JNI函数
 * jobject: java对象“this”的reference

* native的实现 - HelloJNI.c
```java
	#include <jni.h>
	#include <stdio.h>
	#include "HelloJNI.h"

	JNIEXPORT void JNICALL Java_HelloJNI_helloWorld(JNIEnv *, jobject) {
		printf("Say Hello world\n");
		return;
	}
```

#### 1.2 JNI in Package
* JNI的java - myjni\HelloJNI.java
```java
	package myjni;		// package name
	public class HelloJNI {
	   static {
		  System.loadLibrary("hello"); // hello.dll (Windows) or libhello.so (Unixes)
	   }
	   // A native method that receives nothing and returns void
	   private native void sayHello();
	   public static void main(String[] args) {
		  new HelloJNI().sayHello();  // invoke the native method
	   }
	}

	// 编译JNI代码
	> javac myjni\HelloJNI.java
```
* 生成C/C++的头文件
```sh
	// 使用include会让生产的头文件输出路径在inlude目录下：include\myjni_HelloJNI.h
	> javah -d include myini.HelloJNI
```
* C中的实现 - HelloJNI.c
```java
#include <jni.h>
	#include <stdio.h>
	#include "include\myjni_HelloJNI.h"

	JNIEXPORT void JNICALL Java_myjni_HelloJNI_sayHello(JNIEnv *env, jobject thisObj) {
	   printf("Hello World!\n");
	   return;
	}
```


------------------------------------------------------------------------------------


### 二、JNI基础
#### Java的基本类型对应关系
| Java类型 | JNI类型   |
|---------|----------|
| int     | jint     |
| byte    | jbyte    |
| short   | jshort   |
| long    | jlong    |
| float   | jfloat   |
| double  | jdouble  |
| char    | jchar    |
| boolean | jboolean |

#### Java引用类型
| Java类型 | JNI类型   |
|---------|----------|
| java.lang.Object | jobject |
| java.lang.Class  | jclass  |
| java.lang.String | jstring |
| java.lang.Throwable | jthrowable |
| java array  | jarray |
**Java数组是8个基本类型的数组和一个Object的数组的引用。因此有`jintArray`,`jbyteArray`,`jshortArray`,`jlongArray`,`jfloatArray`,`jdoubleArray`,`jcharArray`,`jbooleanArray`和Object的数组`jobjectArray`**

因为JNI中使用的类型如上所示，在C/C++原生的类型中使用的与此不同，所以需要在JNI类型和native类型之间进行转换。


------------------------------------------------------------------------------------


### 三、Java和Native程序之间的参数传递和值返回
#### 3.1 基本类型参数的传递
基本参数的类型直接与native中的基本类型对应，所以不需要做任何转换。
```java
public class TestJNIPrimitive {
   static {
      System.loadLibrary("myjni"); // myjni.dll (Windows) or libmyjni.so (Unixes)
   }
   // Declare a native method average() that receives two ints and return a double containing the average
   private native double average(int n1, int n2);
   // Test Driver
   public static void main(String args[]) {
      System.out.println("In Java, the average is " + new TestJNIPrimitive().average(3, 2));
   }
}


// 生成native的头文件
> javac TestJNIPrimitive.java
> javah TestJNIPrimitive       // Output is TestJNIPrimitive.h


// native的实现TestJNIPrimitive.c
#include <jni.h>
#include <stdio.h>
#include "TestJNIPrimitive.h"

JNIEXPORT jdouble JNICALL Java_TestJNIPrimitive_average
          (JNIEnv *env, jobject thisObj, jint n1, jint n2) {
   jdouble result;
   printf("In C, the numbers are %d and %d\n", n1, n2);
   result = ((jdouble)n1 + n2) / 2.0;
   // jint is mapped to int, jdouble is mapped to double
   return result;
}
```

#### 3.2 String的传递
```java
public class TestJNIString {
   static {
      System.loadLibrary("myjni"); // myjni.dll (Windows) or libmyjni.so (Unixes)
   }
   // Native method that receives a Java String and return a Java String
   private native String sayHello(String msg);

   public static void main(String args[]) {
      String result = new TestJNIString().sayHello("Hello from Java");
      System.out.println("In Java, the returned string is: " + result);
   }
}


// 生成对应的native的头文件
> javac TestJNIString.java
> javah TestJNIString

// 具体的native实现
#include <jni.h>
#include <stdio.h>
#include "TestJNIString.h"

JNIEXPORT jstring JNICALL Java_TestJNIString_sayHello(JNIEnv *env, jobject thisObj, jstring inJNIStr) {
   // Step 1: Convert the JNI String (jstring) into C-String (char*)
   const char *inCStr = (*env)->GetStringUTFChars(env, inJNIStr, NULL);
   if (NULL == inCSt) return NULL;

   // Step 2: Perform its intended operations
   printf("In C, the received string is: %s\n", inCStr);
   (*env)->ReleaseStringUTFChars(env, inJNIStr, inCStr);  // release resources

   // Prompt user for a C-string
   char outCStr[128];
   printf("Enter a String: ");
   scanf("%s", outCStr);    // not more than 127 characters

   // Step 3: Convert the C-string (char*) into JNI String (jstring) and return
   return (*env)->NewStringUTF(env, outCStr);
}
```
Java的String是一个object（参考类型），而C风格的字符串是以NULL结尾的char数组。所以需要在Java String（native中对应为jstring）和C-string（char*）之间转换。

JNI的环境（通过JNIEnv*参数获取）提供相应的string的转换函数：
* jstring -> c-string的调用方法为`const char* GetStringUTFChars(JNIEnv*, jstring, jboolean*)`
* c-string -> jstring的调用方法为`jstring NewStringUTF(JNIEnv*, char*)`

###### JNI Native String Functions
JNI支持对Unicode（16-bit字符集）和UTF-8（1-3字节的编码）的strings。
```c++
// UTF-8 String (encoded to 1-3 byte, backward compatible with 7-bit ASCII)
// Can be mapped to null-terminated char-array C-string
const char * GetStringUTFChars(JNIEnv *env, jstring string, jboolean *isCopy);

// Returns a pointer to an array of bytes representing the string in modified UTF-8 encoding.
void ReleaseStringUTFChars(JNIEnv *env, jstring string, const char *utf);

// Informs the VM that the native code no longer needs access to utf.
jstring NewStringUTF(JNIEnv *env, const char *bytes);
// Constructs a new java.lang.String object from an array of characters in modified UTF-8 encoding.
jsize GetStringUTFLength(JNIEnv *env, jstring string);
// Returns the length in bytes of the modified UTF-8 representation of a string.
void GetStringUTFRegion(JNIEnv *env, jstring str, jsize start, jsize length, char *buf);
// Translates len number of Unicode characters beginning at offset start into modified UTF-8 encoding
// and place the result in the given buffer buf.
// Unicode Strings (16-bit character)
const jchar * GetStringChars(JNIEnv *env, jstring string, jboolean *isCopy);

// Returns a pointer to the array of Unicode characters
void ReleaseStringChars(JNIEnv *env, jstring string, const jchar *chars);

// Informs the VM that the native code no longer needs access to chars.
jstring NewString(JNIEnv *env, const jchar *unicodeChars, jsize length);

// Constructs a new java.lang.String object from an array of Unicode characters.
jsize GetStringLength(JNIEnv *env, jstring string);

// Returns the length (the count of Unicode characters) of a Java string.
void GetStringRegion(JNIEnv *env, jstring str, jsize start, jsize length, jchar *buf);
// Copies len number of Unicode characters beginning at offset start to the given buffer buf
```

###### UTF-8 strings or C-strings
`GetStringUTFChars()`：
> * 通过Java's jstring来创建一个C-string (char*)。该函数内存分配失败时会返回NULL。
* 第三个参数isCopy (of jboolean*),表示返回值是否为原始java.lang.String实例的直接引用或者拷贝，大部分情况直接传NULL作为参数
* 当不在使用`GetStringUTFChars()`函数返回的string时，调用`ReleaseStringUTFChars()`函数，释放内存与引用，使得可以被Java垃圾回收。

在JDK 1.2中引入了`GetStringUTFRegion()`函数，该函数是需要自己提前分配c-string的内存，

###### 【注】在C\++中，使用`env->`代替C中的`(*env)->`，并且在C\++函数中不需要传递`JNIEnv*`参数


#### 3.3 传递基本类型的数组
```java
public class TestJNIPrimitiveArray {
   static {
      System.loadLibrary("myjni"); // myjni.dll (Windows) or libmyjni.so (Unixes)
   }

   // Declare a native method sumAndAverage() that receives an int[] and
   //  return a double[2] array with [0] as sum and [1] as average
   private native double[] sumAndAverage(int[] numbers);

   // Test Driver
   public static void main(String args[]) {
      int[] numbers = {22, 33, 33};
      double[] results = new TestJNIPrimitiveArray().sumAndAverage(numbers);
      System.out.println("In Java, the sum is " + results[0]);
      System.out.println("In Java, the average is " + results[1]);
   }
}
```
在JNI数组和native数组之间需要做转换。eg. jintArray与C的jint[].JNI环境接口（JNI Environment interface）提供了一系列函数用于转换。
* 从JNI的jinArray到native的jint[]的转换：`jint* GetIntArrayElements(JNIEnv *env, jintArray a, jboolean *iscopy)`
* 从native的jint[]到JNI的jintArray的转换：首先调用`jintArray NewIntArray(JNIEnv *env, jsize len)`分配内存，在使用`void SetIntArrayRegion(JNIEnv *env, jintArray a, jsize start, jsize len, const jint *buf)`从jnit[]中拷贝数据到jintArray。

```c++
#include <jni.h>
#include <stdio.h>
#include "TestJNIPrimitiveArray.h"
JNIEXPORT jdoubleArray JNICALL Java_TestJNIPrimitiveArray_sumAndAverage
          (JNIEnv *env, jobject thisObj, jintArray inJNIArray) {
   // Step 1: Convert the incoming JNI jintarray to C's jint[]
   jint *inCArray = (*env)->GetIntArrayElements(env, inJNIArray, NULL);
   if (NULL == inCArray) return NULL;
   jsize length = (*env)->GetArrayLength(env, inJNIArray);

   // Step 2: Perform its intended operations
   jint sum = 0;
   int i;
   for (i = 0; i < length; i++) {
      sum += inCArray[i];
   }
   jdouble average = (jdouble)sum / length;
   (*env)->ReleaseIntArrayElements(env, inJNIArray, inCArray, 0); // release resources
   jdouble outCArray[] = {sum, average};

   // Step 3: Convert the C's Native jdouble[] to JNI jdoublearray, and return
   jdoubleArray outJNIArray = (*env)->NewDoubleArray(env, 2);  // allocate
   if (NULL == outJNIArray) return NULL;
   (*env)->SetDoubleArrayRegion(env, outJNIArray, 0 , 2, outCArray);  // copy
   return outJNIArray;
}
```
###### JNI Primitive Array Functions
```c++
// ArrayType: jintArray, jbyteArray, jshortArray, jlongArray, jfloatArray, jdoubleArray, jcharArray, jbooleanArray
// PrimitiveType: int, byte, short, long, float, double, char, boolean
// NativeType: jint, jbyte, jshort, jlong, jfloat, jdouble, jchar, jboolean
NativeType * Get<PrimitiveType>ArrayElements(JNIEnv *env, ArrayType array, jboolean *isCopy);
void Release<PrimitiveType>ArrayElements(JNIEnv *env, ArrayType array, NativeType *elems, jint mode);
void Get<PrimitiveType>ArrayRegion(JNIEnv *env, ArrayType array, jsize start, jsize length, NativeType *buffer);
void Set<PrimitiveType>ArrayRegion(JNIEnv *env, ArrayType array, jsize start, jsize length, const NativeType *buffer);
ArrayType New<PrimitiveType>Array(JNIEnv *env, jsize length);
void * GetPrimitiveArrayCritical(JNIEnv *env, jarray array, jboolean *isCopy);
void ReleasePrimitiveArrayCritical(JNIEnv *env, jarray array, void *carray, jint mode);
```


------------------------------------------------------------------------------------


### 四、访问对象的变量和回调函数（C++中使用Java的变量和函数）
#### 4.1 访问对象的实例变量
```java
public class TestJNIInstanceVariable {
   static {
      System.loadLibrary("myjni"); // myjni.dll (Windows) or libmyjni.so (Unixes)
   }

   // Instance variables
   private int number = 88;
   private String message = "Hello from Java";

   // Declare a native method that modifies the instance variables
   private native void modifyInstanceVariable();

   // Test Driver
   public static void main(String args[]) {
      TestJNIInstanceVariable test = new TestJNIInstanceVariable();
      test.modifyInstanceVariable();
      System.out.println("In Java, int is " + test.number);
      System.out.println("In Java, String is " + test.message);
   }
}
```
修改class TestJNIInstanceVariable中的私有变量number和message的native代码：
```c++
#include <jni.h>
#include <stdio.h>
#include "TestJNIInstanceVariable.h"

JNIEXPORT void JNICALL Java_TestJNIInstanceVariable_modifyInstanceVariable
          (JNIEnv *env, jobject thisObj) {
   // Get a reference to this object's class
   jclass thisClass = (*env)->GetObjectClass(env, thisObj);

   // int
   // Get the Field ID of the instance variables "number"
   jfieldID fidNumber = (*env)->GetFieldID(env, thisClass, "number", "I");
   if (NULL == fidNumber) return;

   // Get the int given the Field ID
   jint number = (*env)->GetIntField(env, thisObj, fidNumber);
   printf("In C, the int is %d\n", number);

   // Change the variable
   number = 99;
   (*env)->SetIntField(env, thisObj, fidNumber, number);

   // Get the Field ID of the instance variables "message"
   jfieldID fidMessage = (*env)->GetFieldID(env, thisClass, "message", "Ljava/lang/String;");
   if (NULL == fidMessage) return;

   // String
   // Get the object given the Field ID
   jstring message = (*env)->GetObjectField(env, thisObj, fidMessage);

   // Create a C-string with the JNI String
   const char *cStr = (*env)->GetStringUTFChars(env, message, NULL);
   if (NULL == cStr) return;

   printf("In C, the string is %s\n", cStr);
   (*env)->ReleaseStringUTFChars(env, message, cStr);

   // Create a new C-string and assign to the JNI string
   message = (*env)->NewStringUTF(env, "Hello from C");
   if (NULL == message) return;

   // modify the instance variables
   (*env)->SetObjectField(env, thisObj, fidMessage, message);
}
```
> * 通过`GetObjectClass()`获取object类的reference
* 通过`GetFieldID()`从class的reference中获取变量的Filed ID，其中需要给函数提供变量的名字和它filed的描述(参考下面的表)。
* 根据Field ID，使用`GetObjectField()`或者`Get<primitive-type>Field()`获取对应的实例变量
* 根据Field Id，使用`SetObjectField()`或者`Set<primitive-type>Field()`可以更新对应的实例变量

###### Filed Descriptor
| Java type | Filed descriptor |
|-----------|------------------|
| boolean 	| 		Z		   |
| 	int 	| 		I		   |
|   byte	| 		B		   |
| 	char 	| 		C		   |
| 	short	| 		S		   |
| 	float 	| 		F		   |
| 	double 	| 		D		   |
| Java class |   `L<fully-qualified-name>;` |
|   String	 |     Ljava/lang/String;       |
| Java array | 	 `[<descriptor>`			|
|  Object[]  |		[Ljava/lang/Object;		|
|   int[]    |			[I					|

###### JNI中accessing实例变量的函数
```java
jclass GetObjectClass(JNIEnv *env, jobject obj);
// Returns the class of an object.

jfieldID GetFieldID(JNIEnv *env, jclass cls, const char *name, const char *sig);
// Returns the field ID for an instance variable of a class.

NativeType Get<type>Field(JNIEnv *env, jobject obj, jfieldID fieldID);
void Set<type>Field(JNIEnv *env, jobject obj, jfieldID fieldID, NativeType value);
// Get/Set the value of an instance variable of an object
// <type> includes each of the eight primitive types plus Object.
```

#### 4.2 访问class的静态变量
与4.1中访问普通变量差不多，只是使用的函数做一下修改使用：
`GetStaticFieldID()`, `Get|SetStaticObjectField()`, `Get|SetStatic<Primitive-type>Field()`
```java
jfieldID GetStaticFieldID(JNIEnv *env, jclass cls, const char *name, const char *sig);
// Returns the field ID for a static variable of a class.

NativeType GetStatic<type>Field(JNIEnv *env, jclass clazz, jfieldID fieldID);
void SetStatic<type>Field(JNIEnv *env, jclass clazz, jfieldID fieldID, NativeType value);
// Get/Set the value of a static variable of a class.
// <type> includes each of the eight primitive types plus Object.
```

#### 4.3 回调实例的方法和静态方法
```java
public class TestJNICallBackMethod {
   static {
      System.loadLibrary("myjni"); // myjni.dll (Windows) or libmyjni.so (Unixes)
   }

   // Declare a native method that calls back the Java methods below
   private native void nativeMethod();

   // To be called back by the native code
   private void callback() {
      System.out.println("In Java");
   }

   private void callback(String message) {
      System.out.println("In Java with " + message);
   }

   private double callbackAverage(int n1, int n2) {
      return ((double)n1 + n2) / 2.0;
   }

   // Static method to be called back
   private static String callbackStatic() {
      return "From static Java method";
   }

   // Test Driver
   public static void main(String args[]) {
      new TestJNICallBackMethod().nativeMethod();
   }
}
```
对应的native中的实现：
```c++
#include <jni.h>
#include <stdio.h>
#include "TestJNICallBackMethod.h"
JNIEXPORT void JNICALL Java_TestJNICallBackMethod_nativeMethod
          (JNIEnv *env, jobject thisObj) {

   // Get a class reference for this object
   jclass thisClass = (*env)->GetObjectClass(env, thisObj);

   // Get the Method ID for method "callback", which takes no arg and return void
   jmethodID midCallBack = (*env)->GetMethodID(env, thisClass, "callback", "()V");
   if (NULL == midCallBack) return;
   printf("In C, call back Java's callback()\n");
   // Call back the method (which returns void), baed on the Method ID
   (*env)->CallVoidMethod(env, thisObj, midCallBack);

   jmethodID midCallBackStr = (*env)->GetMethodID(env, thisClass,
                               "callback", "(Ljava/lang/String;)V");
   if (NULL == midCallBackStr) return;
   printf("In C, call back Java's called(String)\n");
   jstring message = (*env)->NewStringUTF(env, "Hello from C");
   (*env)->CallVoidMethod(env, thisObj, midCallBackStr, message);

   jmethodID midCallBackAverage = (*env)->GetMethodID(env, thisClass,
                                  "callbackAverage", "(II)D");
   if (NULL == midCallBackAverage) return;
   jdouble average = (*env)->CallDoubleMethod(env, thisObj, midCallBackAverage, 2, 3);
   printf("In C, the average is %f\n", average);

   jmethodID midCallBackStatic = (*env)->GetStaticMethodID(env, thisClass,
                                 "callbackStatic", "()Ljava/lang/String;");
   if (NULL == midCallBackStatic) return;
   jstring resultJNIStr = (*env)->CallStaticObjectMethod(env, thisClass, midCallBackStatic);
   const char *resultCStr = (*env)->GetStringUTFChars(env, resultJNIStr, NULL);
   if (NULL == resultCStr) return;
   printf("In C, the returned string is %s\n", resultCStr);
   (*env)->ReleaseStringUTFChars(env, resultJNIStr, resultCStr);
}
```
在native代码中调用java的函数的步骤：
> * 通过`GetObjectClass()`获取对象类的reference
* 根据class reference调用`GetMethodID()`获取Method ID。需要提供函数的名称和参数类型的signature，signature的形式`(parameters)return-type`，具体怎么写参数类型的signature参考Filed descriptor表。可以通过使用`javah`工具来打印signature
```sh
	> javap --help
	> javap -s -p TestJNICallBackMethod
	  // -s 表示打印出signature
	  // -p 表示显示private的成员
	  private void callback();
		Signature: ()V
	  private void callback(java.lang.String);
		Signature: (Ljava/lang/String;)V
	  private double callbackAverage(int, int);
		Signature: (II)D
	  private static java.lang.String callbackStatic();
		Signature: ()Ljava/lang/String;
```
* 根据Method ID，可以调用`Call<Primitive-type>Method()`、`CallVoidMethod()`或者`CallObjectMethod()`方法来调用实际的java函数（其中`<Primitive-type>`表示返回类型）。

###### JNI中调用普通方法和静态方法的函数有：
```c++
jmethodID GetMethodID(JNIEnv *env, jclass cls, const char *name, const char *sig);
// Returns the method ID for an instance method of a class or interface.

NativeType Call<type>Method(JNIEnv *env, jobject obj, jmethodID methodID, ...);
NativeType Call<type>MethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);
NativeType Call<type>MethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
// Invoke an instance method of the object.
// The <type> includes each of the eight primitive and Object.

jmethodID GetStaticMethodID(JNIEnv *env, jclass cls, const char *name, const char *sig);
// Returns the method ID for an instance method of a class or interface.

NativeType CallStatic<type>Method(JNIEnv *env, jclass clazz, jmethodID methodID, ...);
NativeType CallStatic<type>MethodA(JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
NativeType CallStatic<type>MethodV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
// Invoke an instance method of the object.
// The <type> includes each of the eight primitive and Object.
```

#### 4.4 回调overriden父类的实例方法
如果当前的class B继承于class A，现在想在native中调用父类A中的某个函数（该函数在子类B中已经复写）。
JNI提供了`CallNonvirtual<Type>Method()`函数来调用父类的函数（函数在子类中被继承了，类似于Java中在子类中调用csuper.methodName()来使用父类函数）。
> * 首先调用`GetMethodID()`获取Method Id
* 根据Method ID， 调用`CallNonvirtual<Type>Method()`来使用父类函数，需要指定object、父类以及参数
```c++
	NativeType CallNonvirtual<type>Method(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...);
	NativeType CallNonvirtual<type>MethodA(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, const jvalue *args);
	NativeType CallNonvirtual<type>MethodV(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, va_list args);
```


--------------------------------------------------------------------


### 五、创建Objects和Object数组
我们可以调用`NewObject()`和`newObjectArray()`，在native代码中创建jobject和jobjectArray，然后传回到Java代码中。
#### 5.1 在Native代码中调用构造器创建新的java对象
```java
public class TestJNIConstructor {
   static {
      System.loadLibrary("myjni"); // myjni.dll (Windows) or libmyjni.so (Unixes)
   }

   // Native method that calls back the constructor and return the constructed object.
   // Return an Integer object with the given int.
   private native Integer getIntegerObject(int number);

   public static void main(String args[]) {
      TestJNIConstructor obj = new TestJNIConstructor();
      System.out.println("In Java, the number is :" + obj.getIntegerObject(9999));
   }
}

// getIntegerObject函数调用native来创建并返回Integer对象。
```
对应的Native代码如下：
```c++
#include <jni.h>
#include <stdio.h>
#include "TestJNIConstructor.h"
JNIEXPORT jobject JNICALL Java_TestJNIConstructor_getIntegerObject
          (JNIEnv *env, jobject thisObj, jint number) {
   // Get a class reference for java.lang.Integer
   jclass cls = (*env)->FindClass(env, "java/lang/Integer");

   // Get the Method ID of the constructor which takes an int
   jmethodID midInit = (*env)->GetMethodID(env, cls, "<init>", "(I)V");
   if (NULL == midInit) return NULL;
   // Call back constructor to allocate a new instance, with an int argument
   jobject newObj = (*env)->NewObject(env, cls, midInit, number);

   // Try runnning the toString() on this newly create object
   jmethodID midToString = (*env)->GetMethodID(env, cls, "toString", "()Ljava/lang/String;");
   if (NULL == midToString) return NULL;
   jstring resultStr = (*env)->CallObjectMethod(env, newObj, midToString);
   const char *resultCStr = (*env)->GetStringUTFChars(env, resultStr, NULL);
   printf("In C: the number is %s\n", resultCStr);

   return newObj;
}
```
###### JNI中创建object的相关函数：
```c++
jclass FindClass(JNIEnv *env, const char *name);

jobject NewObject(JNIEnv *env, jclass cls, jmethodID methodID, ...);
jobject NewObjectA(JNIEnv *env, jclass cls, jmethodID methodID, const jvalue *args);
jobject NewObjectV(JNIEnv *env, jclass cls, jmethodID methodID, va_list args);
// Constructs a new Java object. The method ID indicates which constructor method to invoke

jobject AllocObject(JNIEnv *env, jclass cls);
// Allocates a new Java object without invoking any of the constructors for the object.
```

#### 5.2 对象数组创建
```java
import java.util.ArrayList;

public class TestJNIObjectArray {
   static {
      System.loadLibrary("myjni"); // myjni.dll (Windows) or libmyjni.so (Unixes)
   }
   // Native method that receives an Integer[] and
   //  returns a Double[2] with [0] as sum and [1] as average
   private native Double[] sumAndAverage(Integer[] numbers);

   public static void main(String args[]) {
      Integer[] numbers = {11, 22, 32};  // auto-box
      Double[] results = new TestJNIObjectArray().sumAndAverage(numbers);
      System.out.println("In Java, the sum is " + results[0]);  // auto-unbox
      System.out.println("In Java, the average is " + results[1]);
   }
}
```
对应的Native代码如下：
```c++
#include <jni.h>
#include <stdio.h>
#include "TestJNIObjectArray.h"
JNIEXPORT jobjectArray JNICALL Java_TestJNIObjectArray_sumAndAverage
          (JNIEnv *env, jobject thisObj, jobjectArray inJNIArray) {
   // Get a class reference for java.lang.Integer
   jclass classInteger = (*env)->FindClass(env, "java/lang/Integer");
   // Use Integer.intValue() to retrieve the int
   jmethodID midIntValue = (*env)->GetMethodID(env, classInteger, "intValue", "()I");
   if (NULL == midIntValue) return NULL;

   // Get the value of each Integer object in the array
   jsize length = (*env)->GetArrayLength(env, inJNIArray);
   jint sum = 0;
   int i;
   for (i = 0; i < length; i++) {
      jobject objInteger = (*env)->GetObjectArrayElement(env, inJNIArray, i);
      if (NULL == objInteger) return NULL;
      jint value = (*env)->CallIntMethod(env, objInteger, midIntValue);
      sum += value;
   }
   double average = (double)sum / length;
   printf("In C, the sum is %d\n", sum);
   printf("In C, the average is %f\n", average);

   // Get a class reference for java.lang.Double
   jclass classDouble = (*env)->FindClass(env, "java/lang/Double");

   // Allocate a jobjectArray of 2 java.lang.Double
   jobjectArray outJNIArray = (*env)->NewObjectArray(env, 2, classDouble, NULL);

   // Construct 2 Double objects by calling the constructor
   jmethodID midDoubleInit = (*env)->GetMethodID(env, classDouble, "<init>", "(D)V");
   if (NULL == midDoubleInit) return NULL;
   jobject objSum = (*env)->NewObject(env, classDouble, midDoubleInit, (double)sum);
   jobject objAve = (*env)->NewObject(env, classDouble, midDoubleInit, average);
   // Set to the jobjectArray
   (*env)->SetObjectArrayElement(env, outJNIArray, 0, objSum);
   (*env)->SetObjectArrayElement(env, outJNIArray, 1, objAve);

   return outJNIArray;
}
```
与基本类型不同的是，对于对象数组，需要使用`Get|SetObjectArrayElement()`来处理每个元素。
###### JNI中创建和处理对象数组的函数：
```c++
jobjectArray NewObjectArray(JNIEnv *env, jsize length, jclass elementClass, jobject initialElement);
// Constructs a new array holding objects in class elementClass.
// All elements are initially set to initialElement.

jobject GetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index);
// Returns an element of an Object array.

void SetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index, jobject value);
// Sets an element of an Object array.
```


--------------------------------------------------------------------


### 六、局部和全局引用
写高效的程序中管理references十分重要。如在native代码中使用FindClass(), GetMethodID(), GetFieldID()检索jclass, jmethodID和jfieldID。对于替代反复执行调用，这些值应该获取一次然后缓存起来供后面的使用。
> * A local reference is created within the native method, and freed once the method exits. It is valid for the duration of a native method. You can also use JNI function DeleteLocalRef() to invalidate a local reference explicitly, so that it is available for garbage collection intermediately. Objects are passed to native methods as local references. All Java objects (jobject) returned by JNI functions are local references.
* A global reference remains until it is explicitly freed by the programmer, via the DeleteGlobalRef() JNI function. You can create a new global reference from a local reference via JNI function NewGlobalRef().

```java
public class TestJNIReference {
   static {
      System.loadLibrary("myjni"); // myjni.dll (Windows) or libmyjni.so (Unixes)
   }

   // A native method that returns a java.lang.Integer with the given int.
   private native Integer getIntegerObject(int number);

   // Another native method that also returns a java.lang.Integer with the given int.
   private native Integer anotherGetIntegerObject(int number);

   public static void main(String args[]) {
      TestJNIReference test = new TestJNIReference();
      System.out.println(test.getIntegerObject(1));
      System.out.println(test.getIntegerObject(2));
      System.out.println(test.anotherGetIntegerObject(11));
      System.out.println(test.anotherGetIntegerObject(12));
      System.out.println(test.getIntegerObject(3));
      System.out.println(test.anotherGetIntegerObject(13));
   }
}
```
对应的Native代码如下：
```c++
#include <jni.h>
#include <stdio.h>
#include "TestJNIReference.h"
// Global Reference to the Java class "java.lang.Integer"
static jclass classInteger;
static jmethodID midIntegerInit;

jobject getInteger(JNIEnv *env, jobject thisObj, jint number) {

   // Get a class reference for java.lang.Integer if missing
   if (NULL == classInteger) {
      printf("Find java.lang.Integer\n");
      classInteger = (*env)->FindClass(env, "java/lang/Integer");
   }
   if (NULL == classInteger) return NULL;

   // Get the Method ID of the Integer's constructor if missing
   if (NULL == midIntegerInit) {
      printf("Get Method ID for java.lang.Integer's constructor\n");
      midIntegerInit = (*env)->GetMethodID(env, classInteger, "<init>", "(I)V");
   }
   if (NULL == midIntegerInit) return NULL;

   // Call back constructor to allocate a new instance, with an int argument
   jobject newObj = (*env)->NewObject(env, classInteger, midIntegerInit, number);
   printf("In C, constructed java.lang.Integer with number %d\n", number);
   return newObj;
}

JNIEXPORT jobject JNICALL Java_TestJNIReference_getIntegerObject
          (JNIEnv *env, jobject thisObj, jint number) {
   return getInteger(env, thisObj, number);
}

JNIEXPORT jobject JNICALL Java_TestJNIReference_anotherGetIntegerObject
          (JNIEnv *env, jobject thisObj, jint number) {
   return getInteger(env, thisObj, number);
}
```
上面的代码中会有问题，因为 FindClass()返回的是一个局部引用并赋值给`classInteger`这个全局变量，此次调用结束该局部引用就无效了，所以`classInteger`又成NULL了。
== 解决方法是根据FindClass的返回值来创建一个全局引用： ==
```c++
// Get a class reference for java.lang.Integer if missing
if (NULL == classInteger) {
  printf("Find java.lang.Integer\n");
  // FindClass returns a local reference
  jclass classIntegerLocal = (*env)->FindClass(env, "java/lang/Integer");
  // Create a global reference from the local reference
  classInteger = (*env)->NewGlobalRef(env, classIntegerLocal);
  // No longer need the local reference, free it!
  (*env)->DeleteLocalRef(env, classIntegerLocal);
}
```
**【注】jmethodID和jfieldID不是jobject，不能创建全局的reference**




























[0]:https://www3.ntu.edu.sg/home/ehchua/programming/java/JavaNativeInterface.html
[1]:http://developer.android.com/training/articles/perf-jni.html













